#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "lr0b.h"
#include "tokens.h"
#define NUM_STATES #0#
#define NUM_NONTERMS #0#
#define NUM_TERMS #0#
#define SCSTYPE int
void run_parser(void);
int mlexer(FILE* thefile);
void run_code(int state);

char lex_text[128];
void run_parser(void){
    u_int8_t stack[100];
	SCSTYPE values[100];
    memset(stack,0,sizeof(u_int8_t)*100);
    memset(values,0,sizeof(SCSTYPE)*100);
    register u_int8_t* top = &stack[0];
	register SCSTYPE* vtop = &values[0];
    char* file_to_parse;
    FILE* thefile;
    register int tokn;
    register int ntindex;
    const static int GTTBL[NUM_STATES][NUM_NONTERMS] = #0#;
    const static struct action_s ACTION[NUM_STATES][NUM_TERMS] = #0#;
    file_to_parse = malloc(sizeof(char)*128);
    memset(file_to_parse,0,sizeof(char)*128);
    
    printf("input filename to parse\n");
    scanf("%s",file_to_parse);
    if((thefile = fopen(file_to_parse,"r")) == NULL){
	   perror("Error");
	   exit(EXIT_FAILURE);
    }
    tokn = mlexer(thefile);
    printf("token %d\n",tokn);
    while(1){
	   printf("currently in state %d\n",*top);
	   switch(ACTION[*top][tokn].action){
		  case SHIFT:
			    printf("shifting\n");
			    top++;
			    *top = ACTION[*(top-1)][tokn].state;
			    tokn = mlexer(thefile);
			    break;
		  case REDUCE:
			    printf("reducing\n");
			 	run_code(ACTION[(*top)][tokn].state);
			    ntindex = ACTION[(*top)][tokn].rule;
			    printf("reduced by some production %d and head production %d num tokens %d\n",ACTION[*(top)][tokn].state,
					 ACTION[*(top)][tokn].rule,ACTION[*(top)][tokn].numtoks);
			    top = top - (ACTION[*top][tokn].numtoks-1);
			    *top = GTTBL[*(top-1)][ntindex];
			    break;
		  case ACCEPT:
			    printf("accepting\n");
			    goto pender;
			    break;
		  default:
			    printf("parsing error: found error as value in table\n");
			    exit(EXIT_FAILURE);
	   }
    }
pender:
    printf("ending parser\n");
    fclose(thefile);
    free(file_to_parse);
    thefile = NULL;
    file_to_parse = NULL;
}

int mlexer(FILE* thefile){
    int rchar;
    char * ident;
    char * idtemp;
    idtemp = ident = NULL;
    rchar = fgetc(thefile);
    while(rchar != EOF){
	   switch(rchar){
		  case -1:
			 printf("found EOF or '$'\n");
			 return 5;
		  case '+':
			 printf("found +\n");
			 return 0;
			 break;
		  case '*':
			 printf("found *\n");
			 return 1;
			 break;
		  case '(':
			 printf("found (\n");
			 return 2;
			 break;
		  case ')':
			 printf("found )\n");
			 return 3;
			 break;
		  case '\n':
		  case '\t':
		  case ' ':
		  case '\r':
		  case '\f':
			 printf("found ws\n");
			 break;
		  default:
			 if(isalpha(rchar)|| rchar=='_'){
				printf("found id\n");
				ungetc(rchar,thefile);
				idtemp = malloc(sizeof(char)*128);
				memset(idtemp,0,sizeof(char)*128);
				fscanf(thefile,"%s",idtemp);
				ident = malloc(sizeof(char)*strlen(idtemp)+1);
				memset(ident,0,sizeof(char)*strlen(idtemp)+1);
				strncpy(ident,idtemp,sizeof(char)*strlen(idtemp));
				memset(lex_text,0,sizeof(char)*128);
				strncpy(lex_text,ident,sizeof(char)*strlen(ident));
				return 4;
			 }
			 else{
				printf("Character not allowed in the language %c\n",rchar);
				exit(EXIT_FAILURE);
			 }
	   }
	   rchar = fgetc(thefile);

    }
    return 5;
}
inline void run_code(int state){
    switch(state){
		#0#
		default:
			printf("reduced by rule %d\n",state);
			break;
		
    }
}

#0#
